---
title: 设计模式一文总结
date: 2021-04-12
tags: [Software-Design Pattern]
excerpt: 工场模式、抽象工场、生成器、原型、观察者……
---

```toc
# This code block gets replaced with the TOC
```

<Info title="定义">

## 定义

### 设计模式是什么

设计模式是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题。

设计模式与方法或库的使用方式不同， 你很难直接在自己的程序中套用某个设计模式。 模式并不是一段特定的代码， 而是解决特定问题的一般性概念。 你可以根据模式来实现符合自己程序实际所需的解决方案。

人们常常会混淆模式和算法， 因为两者在概念上都是已知特定问题的典型解决方案。 但算法总是明确定义达成特定目标所需的一系列步骤， 而模式则是对解决方案的更高层次描述。 同一模式在两个不同程序中的实现代码可能会不一样。

算法更像是菜谱： 提供达成目标的明确步骤。 而模式更像是蓝图： 你可以看到最终的结果和模式的功能， 但需要自己确定实现步骤。

### 模式包含哪些内容？

大部分模式都有正规的描述方式， 以便在不同情况下使用。 模式的描述通常会包括以下部分：

- **意图**部分简单描述问题和解决方案。
- **动机**部分将进一步解释问题并说明模式会如何提供解决方案。
- **结构**部分展示模式的每个部分和它们之间的关系。
- **在不同语言中的实现**提供流行编程语言的代码， 让读者更好地理解模式背后的思想。
  部分模式介绍中还列出其他的一些实用细节， 例如模式的适用性、 实现步骤以及与其他模式的关系。

### 设计模式分类

不同设计模式的复杂程度、 细节层次以及在整个系统中的应用范围等方面各不相同。 我喜欢将其类比于道路的建造： 如果你希望让十字路口更加安全， 那么可以安装一些交通信号灯， 或者修建包含行人地下通道在内的多层互通式立交桥。

最基础的、 底层的模式通常被称为*惯用技巧*。 这类模式一般只能在一种编程语言中使用。

最通用的、 高层的模式是*构架模式*。 开发者可以在任何编程语言中使用这类模式。 与其他模式不同， 它们可用于整个应用程序的架构设计。

此外， 所有模式可以根据其意图或目的来分类。 本书覆盖了三种主要的模式类别：

- **创建型模式**提供创建对象的机制， 增加已有代码的灵活性和可复用性。

- **结构型模式**介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。

- **行为模式**负责对象间的高效沟通和职责委派。

</Info>

<Primary title="设计模式目录">

- 创建型模式
  - 工场方法模式
  - 抽象工场模式
  - 生成器模式
  - 原型模式
  - 单例模式
- 结构型模式
  - 适配器模式
  - 桥接模式
  - 组合模式
  - 装饰模式
  - 外观模式
  - 享元模式
  - 代理模式
- 行为模式
  - 责任链模式
  - 命令模式
  - 迭代器模式
  - 中介者模式
  - 备忘录模式
  - 观察者模式
  - 状态模式
  - 策略模式
  - 模板方法模式
  - 访问者模式

### 1.1 工厂方法模式

- 问题

对于具有相同方法的不同实现，在不同实现类中，大部分代码都与基类相同，只有少数方法不同

在这种情形下，可以考虑采用工场模式

- 伪代码

![](https://refactoringguru.cn/images/patterns/diagrams/factory-method/structure.png?id=4cba0803f42517cfe854)

以下示例演示了如何使用工厂方法开发跨平台 UI （用户界面） 组件， 并同时避免客户代码与具体 UI 类之间的耦合。

![](https://refactoringguru.cn/images/patterns/diagrams/factory-method/example.png?id=67db9a5cb817913444ef)

- 适用场景

1. 当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。

  > 工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。

例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。

2. 如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。

  > 继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件时， 框架如何辨识出该子类？
  
  > 解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。

  > 让我们看看具体是如何实现的。 假设你使用开源 UI 框架编写自己的应用。 你希望在应用中使用圆形按钮， 但是原框架仅支持矩形按钮。 你可以使用 圆形按钮 Round­Button 子类来继承标准的 按钮 Button 类。 但是， 你需要告诉 UI 框架 UIFramework 类使用新的子类按钮代替默认按钮。

  > 为了实现这个功能， 你可以根据基础框架类开发子类 圆形按钮 UIUIWith­Round­Buttons ， 并且重写其 create­Button 创建按钮方法。 基类中的该方法返回 按钮对象， 而你开发的子类返回 圆形按钮对象。 现在， 你就可以使用 圆形按钮 UI 类代替 UI 框架类。 就是这么简单！

3. 如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。

  > 在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 你会经常碰到这种资源需求。

  > 让我们思考复用现有对象的方法：

  > 首先， 你需要创建存储空间来存放所有已经创建的对象。
  当他人请求一个对象时， 程序将在对象池中搜索可用对象。
  …然后将其返回给客户端代码。
  如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）。
  这些代码可不少！ 而且它们必须位于同一处， 这样才能确保重复代码不会污染程序。

  > 可能最显而易见， 也是最方便的方式， 就是将这些代码放置在我们试图重用的对象类的构造函数中。 但是从定义上来讲， 构造函数始终返回的是新对象， 其无法返回现有实例。

  > 因此， 你需要有一个既能够创建新对象， 又可以重用现有对象的普通方法。 这听上去和工厂方法非常相像。

- 优缺点

**优点**

1. 你可以避免创建者和具体产品之间的紧密耦合。
2. **单一职责原则**。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。
3. **开闭原则**。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。

**缺点**

应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。

- 与其他模式的关系

1. 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。

2. 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。

3. 你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。

4. 原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。

5. 工厂方法是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。

### 1.2 抽象工厂模式

- 问题

假设你正在开发一款家具商店模拟器。 你的代码中包括一些类， 用于表示：

1. 一系列相关产品， 例如 椅子 Chair 、 ​ 沙发 Sofa 和 咖啡桌 Coffee­Table 。

2. 系列产品的不同变体。 例如， 你可以使用 现代 Modern 、 ​ 维多利亚 Victorian 、 ​ 装饰风艺术 Art­Deco 等风格生成 椅子 、 ​ 沙发和 咖啡桌 。

![](https://refactoringguru.cn/images/patterns/diagrams/abstract-factory/problem-zh.png?id=1ce1f5f6b7e0e1e3183d)

你需要设法单独生成每件家具对象， 这样才能确保其风格一致。 如果顾客收到的家具风格不一样， 他们可不会开心。

此外， 你也不希望在添加新产品或新风格时修改已有代码。 家具供应商对于产品目录的更新非常频繁， 你不会想在每次更新时都去修改核心代码的。

- 伪代码

![](https://refactoringguru.cn/images/patterns/diagrams/abstract-factory/structure.png?id=30a2415c54a4b9bab844)

补充说明： 如果客户端仅接触抽象接口， 那么谁来创建实际的工厂对象呢？ 一般情况下， 应用程序会在初始化阶段创建具体工厂对象。 而在此之前， 应用程序必须根据配置文件或环境设定选择工厂类别。

下面例子通过应用抽象工厂模式， 使得客户端代码无需与具体 UI 类耦合， 就能创建跨平台的 UI 元素， 同时确保所创建的元素与指定的操作系统匹配。

![](https://refactoringguru.cn/images/patterns/diagrams/abstract-factory/example.png?id=5928a61d18bf00b04746)

跨平台应用中的相同 UI 元素功能类似， 但是在不同操作系统下的外观有一定差异。 此外， 你需要确保 UI 元素与当前操作系统风格一致。 你一定不希望在 Windows 系统下运行的应用程序中显示 macOS 的控件。

抽象工厂接口声明一系列构建方法， 客户端代码可调用它们生成不同风格的 UI 元素。 每个具体工厂对应特定操作系统， 并负责生成符合该操作系统风格的 UI 元素。

其运作方式如下： 应用程序启动后检测当前操作系统。 根据该信息， 应用程序通过与该操作系统对应的类创建工厂对象。 其余代码使用该工厂对象创建 UI 元素。 这样可以避免生成错误类型的元素。

使用这种方法， 客户端代码只需调用抽象接口， 而无需了解具体工厂类和 UI 元素。 此外， 客户端代码还支持未来添加新的工厂或 UI 元素。

这样一来， 每次在应用程序中添加新的 UI 元素变体时， 你都无需修改客户端代码。 你只需创建一个能够生成这些 UI 元素的工厂类， 然后稍微修改应用程序的初始代码， 使其能够选择合适的工厂类即可。

- 适用场景

1. 如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。

  > 抽象工厂为你提供了一个接口， 可用于创建每个系列产品的对象。 只要代码通过该接口创建对象， 那么你就不会生成与应用程序已生成的产品类型不一致的产品。

2. 如果你有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。

  > 在设计良好的程序中， **每个类仅负责一件事**。 如果一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。

- 优缺点

**优点**

1. 你可以确保同一工厂生成的产品相互匹配。
2. 你可以避免客户端和具体产品代码的耦合。
3. **单一职责原则**。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。
4. **开闭原则**。 向应用程序中引入新产品变体时， 你无需修改客户端代码。

**缺点**

由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。

- 与其他模式的关系

1. 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。

2. 生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。

3. 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。

4. 当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂来代替外观模式。

5. 你可以将抽象工厂和桥接模式搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。

6. 抽象工厂、 生成器和原型都可以用单例模式来实现。

### 1.3 生成器模式

- 问题

假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中； 甚至还有更糟糕的情况， 那就是这些代码散落在客户端代码的多个位置。

![](https://refactoringguru.cn/images/patterns/diagrams/builder/problem1.png?id=11e715c5c97811f848c4)

例如， 我们来思考如何创建一个 房屋House对象。 建造一栋简单的房屋， 首先你需要建造四面墙和地板， 安装房门和一套窗户， 然后再建造一个屋顶。 但是如果你想要一栋更宽敞更明亮的房屋， 还要有院子和其他设施 （例如暖气、 排水和供电设备）， 那又该怎么办呢？

最简单的方法是扩展 房屋基类， 然后创建一系列涵盖所有参数组合的子类。 但最终你将面对相当数量的子类。 任何新增的参数 （例如门廊类型） 都会让这个层次结构更加复杂。

另一种方法则无需生成子类。 你可以在 房屋基类中创建一个包括所有可能参数的超级构造函数， 并用它来控制房屋对象。 这种方法确实可以避免生成子类， 但它却会造成另外一个问题。

![](https://refactoringguru.cn/images/patterns/diagrams/builder/problem2.png?id=2e91039b6c7d2d2df6ee)

通常情况下， 绝大部分的参数都没有使用， 这使得对于构造函数的调用十分不简洁。 例如， 只有很少的房子有游泳池， 因此与游泳池相关的参数十之八九是毫无用处的。

- 伪代码

下面关于生成器模式的例子演示了你可以如何复用相同的对象构造代码来生成不同类型的产品——例如汽车 （Car）——及其相应的使用手册 （Manual）。

![](https://refactoringguru.cn/images/patterns/diagrams/builder/example-zh.png?id=e3d142b1988117313b96)

汽车是一个复杂对象， 有数百种不同的制造方法。 我们没有在 汽车类中塞入一个巨型构造函数， 而是将汽车组装代码抽取到单独的汽车生成器类中。 该类中有一组方法可用来配置汽车的各种部件。

如果客户端代码需要组装一辆与众不同、 精心调教的汽车， 它可以直接调用生成器。 或者， 客户端可以将组装工作委托给主管类， 因为主管类知道如何使用生成器制造最受欢迎的几种型号汽车。

你或许会感到吃惊， 但确实每辆汽车都需要一本使用手册 （说真的， 谁会去读它们呢？）。 使用手册会介绍汽车的每一项功能， 因此不同型号的汽车， 其使用手册内容也不一样。 因此， 你可以复用现有流程来制造实际的汽车及其对应的手册。 当然， 编写手册和制造汽车不是一回事， 所以我们需要另外一个生成器对象来专门编写使用手册。 该类与其制造汽车的兄弟类都实现了相同的制造方法， 但是其功能不是制造汽车部件， 而是描述每个部件。 将这些生成器传递给相同的主管对象， 我们就能够生成一辆汽车或是一本使用手册了。

最后一个部分是获取结果对象。 尽管金属汽车和纸质手册存在关联， 但它们却是完全不同的东西。 我们无法在主管类和具体产品类不发生耦合的情况下， 在主管类中提供获取结果对象的方法。 因此， 我们只能通过负责制造过程的生成器来获取结果对象。

- 适用场景

1. 使用生成器模式可避免 “重叠构造函数 （telescopic constructor）” 的出现。

  > 假设你的构造函数中有十个可选参数， 那么调用该函数会非常不方便； 因此， 你需要重载这个构造函数， 新建几个只有较少参数的简化版。 但这些构造函数仍需调用主构造函数， 传递一些默认数值来替代省略掉的参数。

  ```c++
  class Pizza {
    Pizza(int size) { ... }
    Pizza(int size, boolean cheese) { ... }
    Pizza(int size, boolean cheese, boolean pepperoni) { ... }
    // ...
  ```

2. 当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式。

  > 如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。

  > 基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 同时， 主管类将负责管理制造步骤的顺序。

3. 使用生成器构造组合树或其他复杂对象。

  > 生成器模式让你能分步骤构造产品。 你可以延迟执行某些步骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这在创建对象树时非常方便。

  > 生成器在执行制造步骤时， 不能对外发布未完成的产品。 这可以避免客户端代码获取到不完整结果对象的情况。

- 优缺点

**优点**

1. 你可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。
2. 生成不同形式的产品时， 你可以复用相同的制造代码。
3. **单一职责原则**。 你可以将复杂构造代码从产品的业务逻辑中分离出来。

**缺点**

由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。

- 与其他模式的关系

1. 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。

2. 生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。

3. 你可以在创建复杂组合模式树时使用生成器， 因为这可使其构造步骤以递归的方式运行。

4. 你可以结合使用生成器和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。

5. 抽象工厂、 生成器和原型都可以用单例模式来实现。

### 1.4 原型模式

- 问题

如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。

不错！ 但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。

直接复制还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。

- 伪代码

![](https://refactoringguru.cn/images/patterns/diagrams/prototype/structure-prototype-cache.png?id=609c2af5d14ed55dcbb2)

在本例中， 原型模式能让你生成完全相同的几何对象副本， 同时无需代码与对象所属类耦合。

![](https://refactoringguru.cn/images/patterns/diagrams/prototype/example.png?id=47bc6c1058cb100b81e6)

所有形状类都遵循同一个提供克隆方法的接口。 在复制自身成员变量值到结果对象前， 子类可调用其父类的克隆方法。

- 适用场景

1. 如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。

  > 这一点考量通常出现在代码需要处理第三方代码通过接口传递过来的对象时。 即使不考虑代码耦合的情况， 你的代码也不能依赖这些对象所属的具体类， 因为你不知道它们的具体信息。

  > 原型模式为客户端代码提供一个通用接口， 客户端代码可通过这一接口与所有实现了克隆的对象进行交互， 它也使得客户端代码与其所克隆的对象具体类独立开来。

2. 如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。

  > 在原型模式中， 你可以使用一系列预生成的、 各种类型的对象作为原型。

  > 客户端不必根据需求对子类进行实例化， 只需找到合适的原型并对其进行克隆即可。

- 优缺点

**优点**

1. 你可以克隆对象， 而无需与它们所属的具体类相耦合。
2. 你可以克隆预生成原型， 避免反复运行初始化代码。
3. 你可以更方便地生成复杂对象。
4. 你可以用继承以外的方式来处理复杂对象的不同配置。

**缺点**

克隆包含循环引用的复杂对象可能会非常麻烦。

- 与其他模式的关系

1. 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。

2. 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。

3. 原型可用于保存命令模式的历史记录。

4. 大量使用组合模式和装饰模式的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。

5. 原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。

6. 有时候原型可以作为备忘录模式的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。

7. 抽象工厂、 生成器和原型都可以用单例模式来实现。

### 1.5 单例模式

- 问题

单例模式同时解决了两个问题， 所以违反了_单一职责原则_：

1. **保证一个类只有一个实例**。 为什么会有人想要控制一个类所拥有的实例数量？ 最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。

它的运作方式是这样的： 如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。

注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它必须总是返回一个新对象。

2. **为该实例提供一个全局访问节点**。 还记得你 （好吧， 其实是我自己） 用过的那些存储重要对象的全局变量吗？ 它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。

和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。

还有一点： 你不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。

如今， 单例模式已经变得非常流行， 以至于人们会将只解决上文描述中任意一个问题的东西称为单例。

- 伪代码

![](https://refactoringguru.cn/images/patterns/diagrams/singleton/structure-zh.png?id=207b153c1abb131ee4eb)

单例 （Singleton） 类声明了一个名为 get­Instance获取实例的静态方法来返回其所属类的一个相同实例。

单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 获取实例方法必须是获取单例对象的唯一方式。

- 适用场景

1. 如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。

  > 单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。

2. 如果你需要更加严格地控制全局变量， 可以使用单例模式。

  > 单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。

  > 请注意， 你可以随时调整限制并设定生成单例实例的数量， 只需修改 获取实例方法， 即 getInstance 中的代码即可实现。

- 优缺点

**优点**

1. 你可以保证一个类只有一个实例。
2. 你获得了一个指向该实例的全局访问节点。
3. 仅在首次请求单例对象时对其进行初始化。

**缺点**

1. 违反了_单一职责原则_。 该模式同时解决了两个问题。
2. 单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。
3. 该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。
4. 单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。

- 与其他模式的关系

1. 外观模式类通常可以转换为单例模式类， 因为在大部分情况下一个外观对象就足够了。

2. 如果你能将对象的所有共享状态简化为一个享元对象， 那么享元模式就和单例类似了。 但这两个模式有两个根本性的不同。
  
  2.1 只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。
  
  2.2 单例对象可以是可变的。 享元对象是不可变的。

3. 抽象工厂模式、 生成器模式和原型模式都可以用单例来实现。

### 2.1 适配器模式

- 问题

假如你正在开发一款股票市场监测程序， 它会从不同来源下载 XML 格式的股票数据， 然后向用户呈现出美观的图表。

在开发过程中， 你决定在程序中整合一个第三方智能分析函数库。 但是遇到了一个问题， 那就是分析函数库只兼容 JSON 格式的数据。

![](https://refactoringguru.cn/images/patterns/diagrams/adapter/problem-zh.png?id=05b4229167bc0d74a095)

你可以修改程序库来支持 XML。 但是， 这可能需要修改部分依赖该程序库的现有代码。 甚至还有更糟糕的情况， 你可能根本没有程序库的源代码， 从而无法对其进行修改。

- 伪代码

你可以创建一个适配器。 这是一个特殊的对象， 能够转换对象接口， 使其能与其他对象进行交互。

![](https://refactoringguru.cn/images/patterns/diagrams/adapter/solution-zh.png?id=52af7bf3841ac7f393ff)

有时你甚至可以创建一个双向适配器来实现双向转换调用。

适配器可以有两种类型：

1. 对象适配器

实现时使用了构成原则： 适配器实现了其中一个对象的接口， 并对另一个对象进行封装。 所有流行的编程语言都可以实现适配器。

![](https://refactoringguru.cn/images/patterns/diagrams/adapter/structure-object-adapter.png?id=33dffbe3aece29416244)

2. 类适配器

这一实现使用了继承机制： 适配器同时继承两个对象的接口。 请注意， 这种方式仅能在支持多重继承的编程语言中实现， 例如 C++。

![](https://refactoringguru.cn/images/patterns/diagrams/adapter/structure-class-adapter.png?id=e1c60240508146ed3b98)

事实上 JS/TS 也支持多重继承，毕竟 JS 的 class 只是一个语法糖，可以较为轻松的操作类原型属性，使其只是类成员变量的拓展

下列适配器模式演示基于经典的 “方钉和圆孔” 问题。

![](https://refactoringguru.cn/images/patterns/diagrams/adapter/example.png?id=9d2b6857ce256f2c6693)

- 适用场景

1. 当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。

  > 适配器模式允许你创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。

2. 如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。

  > 你可以扩展每个子类， 将缺少的功能添加到新的子类中。 但是， 你必须在所有新子类中重复添加这些代码， 这样会使得代码有坏味道。

  > 将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后你可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。 如要这一点正常运作， 目标类必须要有通用接口， 适配器的成员变量应当遵循该通用接口。 这种方式同装饰模式非常相似。

- 优缺点

**优点**

1. _单一职责原则_你可以将接口或数据转换代码从程序主要业务逻辑中分离。
2. 开闭原则。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。

**缺点**

代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。

- 与其他模式的关系

1. 桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。

2. 适配器可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。

3. 适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。

4. 外观模式为现有对象定义了一个新接口， 适配器则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。

5. 桥接、 状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。

### 2.2 桥接模式

- 问题

假如你有一个几何 形状Shape类， 从它能扩展出两个子类： ​ 圆形Circle和 方形Square 。 你希望对这样的类层次结构进行扩展以使其包含颜色， 所以你打算创建名为 红色Red和 蓝色Blue的形状子类。 但是， 由于你已有两个子类， 所以总共需要创建四个类才能覆盖所有组合， 例如 蓝色圆形Blue­Circle和 红色方形Red­Square 。

![](https://refactoringguru.cn/images/patterns/diagrams/bridge/problem-zh.png?id=b629ac68586280f371d1)

在层次结构中新增形状和颜色将导致代码复杂程度指数增长。 例如添加三角形状， 你需要新增两个子类， 也就是每种颜色一个； 此后新增一种新颜色需要新增三个子类， 即每种形状一个。 如此以往， 情况会越来越糟糕。

- 伪代码

示例演示了桥接模式如何拆分程序中同时管理设备及其遥控器的庞杂代码。 ​ 设备Device类作为实现部分， 而 遥控器Remote类则作为抽象部分。

![](https://refactoringguru.cn/images/patterns/diagrams/bridge/example-zh.png?id=57c1135dacb5e0c69dbf)

遥控器基类声明了一个指向设备对象的引用成员变量。 所有遥控器通过通用设备接口与设备进行交互， 使得同一个遥控器可以支持不同类型的设备。

你可以开发独立于设备类的遥控器类， 只需新建一个遥控器子类即可。 例如， 基础遥控器可能只有两个按钮， 但你可在其基础上扩展新功能， 比如额外的一节电池或一块触摸屏。

客户端代码通过遥控器构造函数将特定种类的遥控器与设备对象连接起来。

- 适用场景

- 优缺点

**优点**

**缺点**

- 与其他模式的关系

### 2.3 组合模式

- 问题

- 伪代码

- 适用场景

- 优缺点

**优点**

**缺点**

- 与其他模式的关系

### 2.4 装饰模式

- 问题

- 伪代码

- 适用场景

- 优缺点

**优点**

**缺点**

- 与其他模式的关系

### 2.5 外观模式

- 问题

- 伪代码

- 适用场景

- 优缺点

**优点**

**缺点**

- 与其他模式的关系

### 2.6 享元模式

- 问题

- 伪代码

- 适用场景

- 优缺点

**优点**

**缺点**

- 与其他模式的关系

### 2.7 代理模式

- 问题

- 伪代码

- 适用场景

- 优缺点

**优点**

**缺点**

- 与其他模式的关系

### 3.1 责任链模式

- 问题

- 伪代码

- 适用场景

- 优缺点

**优点**

**缺点**

- 与其他模式的关系

### 3.2 命令模式

- 问题

- 伪代码

- 适用场景

- 优缺点

**优点**

**缺点**

- 与其他模式的关系

### 3.3 迭代器模式

- 问题

- 伪代码

- 适用场景

- 优缺点

**优点**

**缺点**

- 与其他模式的关系

### 3.4 中介者模式

- 问题

- 伪代码

- 适用场景

- 优缺点

**优点**

**缺点**

- 与其他模式的关系

### 3.5 备忘录模式

- 问题

- 伪代码

- 适用场景

- 优缺点

**优点**

**缺点**

- 与其他模式的关系

### 3.6 观察者模式

- 问题

- 伪代码

- 适用场景

- 优缺点

**优点**

**缺点**

- 与其他模式的关系

### 3.7 状态模式

- 问题

- 伪代码

- 适用场景

- 优缺点

**优点**

**缺点**

- 与其他模式的关系

### 3.8 策略模式

- 问题

- 伪代码

- 适用场景

- 优缺点

**优点**

**缺点**

- 与其他模式的关系

### 3.9 模板方法模式

- 问题

- 伪代码

- 适用场景

- 优缺点

**优点**

**缺点**

- 与其他模式的关系

### 3.10 访问者模式

- 问题

- 伪代码

- 适用场景

- 优缺点

**优点**

**缺点**

- 与其他模式的关系

</Primary>

<Warning title="参考连接">

## 参考连接

1. [Refactoring GURU](https://refactoringguru.cn/design-patterns)

</Warning>
