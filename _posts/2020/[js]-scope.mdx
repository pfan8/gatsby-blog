---
title: JavaScript 作用域、闭包详解
date: 2021-04-14
tags: [JavaScript]
excerpt: Scope, Closure, this, call, apply
---

<Info>

JS 属于静态词法作用域，正是由于这个原因，导致 JS 中的变量和 `this` 指向变得很奇怪，所以本文就该问题进行了详细展开，让我们彻底把这个问题弄懂，因为……这也是面试高频考点之一 XD

</Info>

<Primary title="call、apply、bind">

- call

一句话介绍 call：

> call 就是指定一个 `this` 对象以及提供一系列参数来调用函数主体

例如:

```javascript
var foo = {
  value: 1,
}

function bar() {
  console.log(this.value)
}

bar.call(foo) // 1
```

注意两点：

1. call 改变了 `this` 的指向，指向到 foo
2. bar 函数执行了

模拟实现 call，要点如下：

1. 将函数 bind 到指定 `this` 对象中，从而获得执行上下文，执行完成后再删除
2. 为了模拟 ES3 中实现不定长传参，要结合 `arguments` 字符串数组和 `eval` 来实现，否则用 ES6 的剩余操作符（...）即可
3. `this` 参数可以传 `null`，这时 `this` 指向全局作用域（window 或 globalThis）

```javascript
Function.prototype.myCall = function (context) {
  var context = context || window || globalThis
  context.fn = this
  var args = []
  for (let i = 1, len = arguments.length; i < len; i++) {
    args.push("arguments[" + i + "]")
  }

  eval("context.fn(" + args + ")")
  delete context.fn
}

var value = 1
var foo = {
  value: 2,
}

function bar(name, age) {
  console.log(name)
  console.log(age)
  console.log(this.value)
}

bar.myCall(foo, "pfan", 28)
// pfan
// 28
// 2
bar.myCall(null, "pfan", 28)
// pfan
// 28
// 1
```

- apply

`apply` 和 `call` 很像，唯一的区别就是，`apply` 只有 2 个参数，第二个参数是函数形参数组，而非 `call` 里面展开成多个参数

```javascript
Function.prototype.apply = function (context, arr) {
  var context = Object(context) || window
  context.fn = this

  var result
  if (!arr) {
    result = context.fn()
  } else {
    var args = []
    for (var i = 0, len = arr.length; i < len; i++) {
      args.push("arr[" + i + "]")
    }
    result = eval("context.fn(" + args + ")")
  }

  delete context.fn
  return result
}
```

- bind

一句话介绍 bind:

> bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )

由此我们可以首先得出 bind 函数的两个特点：

1. 返回一个函数
2. 可以传入参数
   3\*（没有显示提出，但是属于 bind 特性）. 一个绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。

实现如下：

```javascript
Function.prototype.myBind = function (context) {
  var self = this // this 是函数调用者，不用 self 的话，当 this 是 window 的时候，会导致 this.apply 不生效
  args = Array.prototype.slice.call(arguments, 1)

  var fBound = function () {
    var callArgs = Array.prototype.slice.call(arguments)
    // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值
    // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性
    // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context
    return this.apply(
      this instanceof fBound ? this : context,
      args.concat(callArgs)
    )
  }
  // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值
  fBound.prototype = this.prototype
  return fBound
}
```

但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转：

```javascript
Function.prototype.bind2 = function (context) {
  var self = this
  var args = Array.prototype.slice.call(arguments, 1)

  var fNOP = function () {}

  var fBound = function () {
    var bindArgs = Array.prototype.slice.call(arguments)
    return self.apply(
      this instanceof fNOP ? this : context,
      args.concat(bindArgs)
    )
  }

  fNOP.prototype = this.prototype
  fBound.prototype = new fNOP()
  return fBound
}
```

接下来处理些小问题:

1.调用 bind 的不是函数咋办？

不行，我们要报错！

```javascript
if (typeof this !== "function") {
  throw new Error(
    "Function.prototype.bind - what is trying to be bound is not callable"
  )
}
```

2.我要在线上用

那别忘了做个兼容：

```javascript
Function.prototype.bind = Function.prototype.bind || function () {
    ……
};
```

当然最好是用 [es5-shim](https://github.com/es-shims/es5-shim) 啦。

</Primary>

<Warning title="参考连接">

1. [JavaScript 深入系列](https://github.com/mqyqingfeng/Blog)

</Warning>
