---
title: TypeScript 知识点总结
date: 2021-04-08
tags: [TypeScript]
excerpt: TS介绍，编译器，基本数据类型，接口，泛型，高级用法...
---

<Info title="前言">

### TypeScript 三大疑问

1. 是什么？

   TypeScript（简称TS）是一门讲 JavaScript 进行封装，对类型进行静态检查的工具 - `tools`（[官方](https://www.typescriptlang.org/)是这么说的），简单来说，可以将 TS 理解为 JS 的超集，如果你熟悉 ES5/6，那么 TS 和他们的关系可以形象的描绘成下图

   ![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1607150457181-1525aa41-e74b-4499-8899-d6aad2790d81.png)

   TS 提供了静态类型定义的功能，灵活的接口及复杂对象的定义，使得 TS 成为十分强大的工具，在社区保持着非常高的活跃度，与此同时，TS 也是微软的开源项目，你甚至可以到 github 查看 TS 的源码，提 issue 和 PR 。

2. 为什么？

   我们先看看在 JavaScript 项目中最常见的十大错误：

   ![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1607150457323-21590262-0c8e-466c-bff1-2bebd93ec754.png)

   我们是不是耳熟能详？这些低级错误占用了大量 debug 和 google 的时间，而如果你用 TypeScript 可以在编写阶段就规避了，自从我们用了 TypeScript 之后，低级报错基本就没犯过，大多数情况下是我们自身编写的程序逻辑错误。

   很多项目，尤其是中大型项目，我们是需要团队多人协作的，那么如何保证协作呢？这个时候可能需要大量的文档和注释，显式类型就是最好的注释，而通过 TypeScript 提供的类型提示功能我们可以非常舒服地调用同伴的代码，由于 TypeScript 的存在我们可以节省大量沟通成本、代码阅读成本等等。

   ![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1607150457214-74efc77c-ef6c-4e20-a70f-8287b4699b3d.png)

   如果上述两个主要优点还不能吸引你的话，那么我可以负责任地告诉你，升职加薪需要 TS，怎么样，香不香 XD

3. 怎么做到的？

   分两种模式：

   1. 如果在 `tsc` 等指令执行之前，IDE 发现了 ts 中的语法错误，这是通过 IDE 和 LSP 来实现的，更为详细的讲解在[下一节](#Ⅱ. TypeScript 工作原理)
   2. Typescript 编译器将对应的 ts 文件，根据你在 tsconfig.json 中指定好的模式，将 ts 文件编译成 js 文件，这个编译器借助 node 引擎实现，并在执行过程中对 ts 代码进行检查，如果发现错误则停止编译，并打印错误信息。如果有 map 文件，还会提示对应 ts 文件中出错的行数

4. 权衡

   一个新的技术，在使用之前的调研阶段，通常都会对其进行权衡，因为大部分情况下这项技术一定有优缺点，有它自身的适用场景，那么对于 TS 来说，上面说了那么多优点，下面说一下主要问题：

   + 配置以及用好 TS 需要一定的学习成本，并且由于 TS 技术不如 JS 那么成熟，社区也不如 JS 丰富，对于一些问题解答以及工具数量都远不如 JS 和 node，需要承担一定的风险
   + 如果不打算重写 JS 项目，只是加上 TS 编译器的话，原先的组件接口并不能享受 TS 带来的红利—— IDE 中输入或者鼠标悬浮没有接口参数提示，没有类型检查，这样其实使用 TS 的意义就小了很多。

   但是综上来看，绝大部分场景下使用 TS 是利大于弊的，即便是对于个人项目而言，减少不必要的低级错误所省下的时间，通常来说都比你多写一些 TS 类型定义的代码花费时间要多，只是需要你学会 TS 并用好 TS : )

总而言之，你可以将 TS 当做一种语法糖，但 TS 的核心思想是想讲 JS 转换成静态语言，如果微软真的在下一盘大棋，TS 积累了足够的用户群体后，脱离 V8，babel 等编译环境，成为真正的静态语言的话，那就真是将前端彻底洗牌了，不可谓不 NB 啊！当然目前仅仅是对其的猜测，具体如何，需要继续观望，但是无论怎样，使用 TS 依然成为一种流行趋势，TS 确实是一个强大而高效的工具，能够帮助我们在大型 node 项目开发过程中避免一些低级错误以及更好的 IDE 接口提示，提高团队整体的开发效率。

TS 是不是银弹，我们不得而知，但是学好并用好 TS，一定对你的前端生涯有不小的帮助

### TypeScript 工作原理

要用好 TS，一个好的 IDE 是必须的，首推 VS Code，因为是微软自家的产品，自然整合的最好。

那么为什么一定要 IDE 呢，这也和 TS 的工作机制有关，TS 的源代码是以两种独立方式处理的：

+ 检查打开的编辑器是否存在错误：这是通过所谓的 [*language server*](https://langserver.org/) 完成的。它们是与编辑器无关的方法，可为编辑器提供与语言相关的服务（检测错误、重构、自动完成等）。编辑器（例如IDE）通过特殊协议（JSON-RPC，即基于JSON的远程过程调用）与语言服务器进行通信。这样一来，几乎可以用任何编程语言编写此类服务器。
  - 要记住：language server 仅列出当前打开的编辑器的错误，且不编译 TypeScript，而是仅仅静态分析它。
+ *Building*（将 TypeScript 文件编译为 JavaScript 文件）：在这里，我们有两个选择。
  - 我们可以通过命令行运行构建工具。例如，TypeScript 编译器 `tsc` 有 `--watch` 模式，该模式可以监视输入文件，并在更改文件时将其编译为输出文件。这样，每当我们在 IDE 中保存 TypeScript 文件时，都会立即获得相应的输出文件。
  - 我们可以在 Visual Studio Code 中运行 `tsc`。为此，必须将其安装在我们当前正在开发的项目内部或进行全局安装（通过 Node.js 包管理器 npm）。

通过构建，我们可以获得完整的错误列表。有关在 Visual Studio Code 中编译 TypeScript 的更多信息，请参见[该 IDE 的官方文档](https://code.visualstudio.com/docs/typescript/typescript-compiling)。

给定 TypeScript 文件 `main.ts`，TypeScript 编译器可以产生几种工件。最常见的是：

- JavaScript文件：`main.js`
- 声明文件：`main.d.ts`（包含类型信息）
- 源码映射文件：`main.js.map`

TypeScript 通常不是通过 `.ts` 文件提供的，而是通过 `.js` 文件和 `.d.ts` 文件提供：

- JavaScript 代码包含实际的功能，可以通过普通 JavaScript 使用。
- 声明文件可帮助编程编辑者实现自动补全和类似的服务。此信息使普通 JavaScript 可以通过 TypeScript 使用。但是如果使用纯 JavaScript，我们甚至会从中受益，因为它可以提供更好的自动完成以及更多功能。

源码映射为 `main.js` 中输出代码的每一部分指定在 `main.ts` 中的输入代码的哪一部分生成了它。除其他外，此信息使运行时环境能够执行 JavaScript 代码，同时在错误信息中显示 TypeScript 代码的行号。

### TypeScript for Tooling

TypeScript 除了能够发现我们 ts code 中的 bug，还可以在你编辑的时候就帮助你更好地避免产生这些 bug，也就是说在 IDE 中能帮助我们 coding，包括函数调用提示面板，自动修复提示（quick fixes），直接跳转到接口定义等等。这些功能都是通过 type-check 实现的，而以下这些主流 IDE 都对 TS 有良好的支持，并且是跨平台的：

- [alm.tools](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support#alm)
- [Atom](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support#atom)
- [CATS](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support#cats)
- [Eclipse](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support#eclipse)
- [Emacs](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support#emacs)
- [NeoVim](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support#neovim)
- [NetBeans](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support#netbeans)
- [Notepad++](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support#notepad)
- [Sublime Text](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support#sublime-text)
- [Vim](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support#vim)
- [Visual Studio](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support#visual-studio-20132015)
- [Visual Studio Code](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support#visual-studio-code)
- [WebStorm](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support#webstorm)

详细可以查看[官方文档](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support)

### the TypeScript compiler

主流的 TS 编译器工具有 3 个：

- tsc：TS 官方的编译器，作为 type-checker，只有 tsc 可以做 type-checking，代价就是耗时，同时其编译参数也是最丰富的。
- ts-node：相当于是一个 node 的可执行环境，并且包含 TS 支持的模块可以运行过程中编译 TS，实际使用中就相当于可以直接执行 ts 文件而不用输出 js，另外，ts-node 可以指定 TS 编译器，默认是用 tsc
- babel + ts-plugin：babel 有自己的 TS 转换插件 `@babel/plugin-transform-typescript`，但是这个插件相比 tsc 少了一些功能：它没有 type-checking，并且只会转换单个文件，导致其无法理解整个项目的类型系统，如果指定 ts-config 的 `isolatedModules `可以告诉 TS 如果有一些文件无法用 babel 这样的单文件转换工具进行正确地解释，就进行 warn 提示

除此之外，还有 `swc` 以及 `Sucrase` 等是可兼容 TS 的转换器（注意，是 transpiler，而不是 compiler，只有 tsc 是 compiler）

#### 关于 TS 中的 Errors

如果在 ts 文件中有错误，用 `tsc` 编译时默认依然会输出 js 文件，甚至有可能你能成功运行该 js 文件，但是行为不符合预期，例如：

```typescript
// This is an industrial-grade general-purpose greeter function:
function greet(person, date) {
  console.log(`Hello ${person}, today is ${date}!`)
}

greet("Brendan")
```

`tsc` 之后你可以得到：

```javascript
// This is an industrial-grade general-purpose greeter function:
function greet(person, date) {
  console.log("Hello " + person + ", today is " + date + "!")
}
greet("Brendan")
```

甚至你运行可以看到结果

```
Hello Brendan, today is undefined!
```

但是 undefined 多半不是我们的预期结果

如果想要让 `tsc` 在编译时不 skip error，一旦有错就不生成 js 文件的话，可以添加 `--noEmitOnError`参数，例如上述文件（假设为 `ts_study.ts`），运行

```shell
❯ tsc --noEmitOnError ts_study.ts
ts_study.ts:17:1 - error TS2554: Expected 2 arguments, but got 1.

17 greet("Brendan");
   ~~~~~~~~~~~~~~~~

  ts_study.ts:13:24
    13 function greet(person, date) {
                              ~~~~
    An argument for 'date' was not provided.


Found 1 error.
```

就会提示报错，并且不生成对应的 js 文件

### TypeScript 编译 JavaScript

TypeScript 编译器还可以处理普通的 JavaScript 文件：

- 使用选项 `--allowJs`，TypeScript 编译器将输入目录中的 JavaScript 文件复制到输出目录中。好处：当[从 JavaScript 迁移到 TypeScript](https://mp.weixin.qq.com/s/-NEcWkXssKGQh2HDVtBLhA) 时，我们可以先使 JavaScript 和 TypeScript 文件混合存在，然后再慢慢把更多 JavaScript 文件转换为 TypeScript 。
- 使用选项 `--checkJs`，编译器还会对 JavaScript 文件进行类型检查（必须启用 `--allowJs` 才能使该选项起作用）。鉴于可用信息有限，它会尽其所能。
- 如果 JavaScript 文件包含注释 `//@ts-nocheck`，则不会对其进行类型检查。
  - 如果没有 `--checkJs`，注释 `//@ts-check` 可用于对单个 JavaScript 文件进行类型检查。
- TypeScript 编译器使用通过 JSDoc 注释指定的静态类型信息（请参见下面的例子）。如果可以的话，我们可以完全静态类型化纯 JavaScript 文件，甚至可以派生它们的声明文件。
- 使用选项 `--noEmit`，编译器不会产生任何输出，它只会对文件进行类型检查。

This is an example of a JSDoc comment that provides static type information for a function `add()`:
这是一个 JSDoc 注释的例子，它为函数 `add()` 提供静态类型信息：

```
/**
 * @param {number} x - A number param.
 * @param {number} y - A number param.
 * @returns {number} This is the result
 */
function add(x, y) {
  return x + y;
}
```

详细信息：《 TypeScript手册》中的 [Type-Checking JavaScript Files](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html)。

### 关于打包

npm 注册表是一个巨大的 JavaScript 代码库。如果要使用 TypeScript 中的 JavaScript包，则需要类型信息：

- 软件包本身可能包含 `.d.ts` 文件，甚至完整的 TypeScript 代码。
- 如果没有，我们仍然可以使用它：[DefinitelyTyped](https://definitelytyped.org/)是人们为普通 JavaScript 包编写的声明文件的库。

DefinitelyTyped 的声明文件位于 `@types` 命名空间中。所以如果我们需要像 `lodash` 这样的包的声明文件，则必须安装 `@types/lodash` 包。

</Info>

<Primary title="1. 基础类型">

以下左边对应 JavaScript，右边是 TypeScript

- Boolean：boolean
- Number：number
- String：string
- 空值：void（ TS 中的 void 并不是 JS 中的 void ）
- Null：null
- Undefined：undefined
- Symbol：symbol
- BigInt：bigint

可以看出基本上 TS 中的基本类型就是讲 JS 中的各种基本类型的原型名改为小写

需要注意，void 在 JS 中是一个操作符，表示后面的`function`或者`expression`总是返回 undefined，例如：

```javascript
let i = void 2 // i === undefined

void (function aRecursion(i) {
  if (i > 0) {
    console.log(i--)
    aRecursion(i)
  }
})(3)

console.log(typeof aRecursion) // undefined
```

至于好处就是，如果你的 app 里某个接口要求必须返回 undefined 或者在异常时只接受 undefined 的结果，其他结果会报错，那么用 void 可以保证 app 不会 crash：

```javascript
// returning something else than undefined would crash the app
function middleware(nextCallback) {
  if (conditionApplies()) {
    return void nextCallback()
  }
}
// or
button.onclick = () => void doSomething()
```

而 TS 中的 void 是一种类型，相当于 undefined 的一个子类，表示函数不返回值，而在 js 里如果函数没有显示调用 return，则默认返回 undefined 作为函数返回值。然而需要注意，TS 中，void 不等同于 undefined，TS 官网对 `void` 的定义：

> `void` represents the return value of functions which don’t return a value. It’s the inferred type any time a function doesn’t have any `return` statements, or doesn’t return any explicit value from those return statements:

注意最后一句话 `or doesn’t return any explicit value from those return statements:`，意思就是你虽然定义了 void，但是作为函数可以返回任何值，所以如果你用 undefined 就会报错但是 `void` 不会：

```typescript
function doSomething(callback: () => void) {
  // at this position, callback always returns undefined
  let c = callback()
  //c is also of type undefiend
}

// this function returns a number
function aNumberCallback(): number {
  return 2;
}

// works 👍 type safety is ensured in doSometing
doSomething(aNumberCallback)

// if you change the code above like
- function doSomething(callback: () => void) {
+ function doSomething(callback: () => undefined) { /* ... */ }

function aNumberCallback(): number { return 2; }

// 💥 types don't match
doSomething(aNumberCallback)
```

官网的解释说 `void` 的含义应当是不指望函数返回任何结果，实际上函数你返回什么东西我不 care，所以导致这个结果，我觉得也 make sense，不然直接用 undefined 不就好了

#### P.S. 补充

1. 很多时候我们并不需要显示声明变量的类型，例如

```typescript
let msg: string = "hello there!"
// equal to
let msg = "hello there!"
```

因为 TypeScript 能够推断（infer）出 `msg` 变量是 string，并且在 IDE 中，当鼠标 hover 在 msg 上时，会自动弹出 TS 的类型提示

2. TS 可以做 downleveling ：downleveling 是指在编译 TS 到 JS 时，对应的 ECMAScript 版本，TS 能够直接将 TS 代码转换成低版本的 ECMAScript， 通过 `--target` 参数可以在 `tsc` 中指定， 例如：

```shell
tsc --target es2015 input.ts
```

​ 或者在 tsconfig.json （babel）中指定

3. 最主要、实用的 2 个 TS 编译选项（in tsconfig.json）：
   - `noImplicitAny`：如果 TS 推测一个变量类型是 `any`，则会抛出错误，除非你显示指定变量类型是 `any` ，因为如果变量都是 `any`，那也失去了实用 TypeScript 的意义
   - `strictNullChecks`：TS 中，`null` 和 `undefined` 默认可以赋值任何值，因为任何类型都不能明确定义不包含 `null` 和 `undefined`，但是不处理 `null` 和 `undefined` 会造成很多错误，例如注明的[billion dollar mistake](https://www.youtube.com/watch?v=ybrQvs4x0Ps&ab_channel=JoseCan)。而在严格空检查模式（`strictNullChecks`）下， `null` 和 `undefined` 值都 _不_ 属于任何一个类型，它们只能赋值给自己这种类型或者 `any` (有一个例外，`undefined` 也可以赋值给 `void`)。因此，在常规类型检查模式下 `T` 和 `T | ndefined` 被认为是等同的（因为 `undefined` 被看作 `T` 的子类型），但它们在严格类型检查模式下是不同的类型，只有 `T | undefined` 类型允许出现 `undefined` 值。`T` 和 `T | null` 也是这种情况。

</Primary>

<Primary title="1* 其他常见类型">

### never

never 类型表示的是那些永不存在的值的类型，never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。

> 即使 any 也不可以赋值给 never。

两个场景中 never 比较常见:

```
// 抛出异常的函数永远不会有返回值
function error(message: string): never {
    throw new Error(message);
}
// 空数组，而且永远是空的
const empty: never[] = []
```

### 元组（Tuple）

元组类型与数组类型非常相似，表示一个已知元素数量和类型的数组，各元素的类型不必相同。

比如，你可以定义一对值分别为`string`和`number`类型的元组。

```
let x: [string, number];
x = ['hello', 10, false] // Error
x = ['hello'] // Error
```

我们看到，这就是元组与数组的不同之处，元组的类型如果多出或者少于规定的类型是会报错的，必须严格跟事先声明的类型一致才不会报错。

那么有人会问，我们的类型完全一致，只是顺序错了有没有问题，比如上个例子中我们把 `string`、`number` 调换位置：

```
let x: [string, number];
x = ['hello', 10]; // OK
x = [10, 'hello']; // Error
```

我们看到，元组非常严格，即使类型的顺序不一样也会报错。

元组中包含的元素，必须与声明的类型一致，而且不能多、不能少，甚至顺序不能不符。

我们可以把元组看成严格版的数组，比如`[string, number]`我们可以看成是:

```
interface Tuple extends Array<string | number> {
  0: string;
  1: number;
  length: 2;
}
```

元组继承于数组，但是比数组拥有更严格的类型检查。

### Object

object 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型。

```
// 这是下一节会提到的枚举类型
enum Direction {
    Center = 1
}
let value: object
value = Direction
value = [1]
value = [1, 'hello']
value = {}
```

我们看到,普通对象、枚举、数组、元组通通都是 `object` 类型。

### Enum

关于 Enum 的详细讲解可以查看[博客](https://g.yuque.com/cuggz/ts/dzzf93)第 6 节，这里主要讲一下枚举的本质：

例如如下 ts 代码

```typescript
enum Direction {
  Up = 10,
  Down,
  Left,
  Right,
}
```

在经过 `tsc` 编译过后会得到：

```javascript
var Direction
;(function (Direction) {
  Direction[(Direction["Up"] = 10)] = "Up"
  Direction[(Direction["Down"] = 11)] = "Down"
  Direction[(Direction["Left"] = 12)] = "Left"
  Direction[(Direction["Right"] = 13)] = "Right"
})(Direction || (Direction = {}))
```

从而你可以得到 `Direction[10] === 'Up'` 以及 `Direction['Up'] === 10`，也就是 `key <=> value` 双向绑定，所以 Enum 实际上就是一个经过特殊处理的 Object

查看如下代码：

```typescr
enum Enum {
  A,
}

let a = Enum.A;
let nameOfA = Enum[a]; // "A"
```

这样可以看到反向映射的作用，不过实际应用场景应该不多

另外关于 `const` enums 和 enums vs object，可以查看[官网](https://www.typescriptlang.org/docs/handbook/enums.html)的说明，这里就不再赘述

</Primary>

<Primary title="2. Type 和 Interface">

Type 和 Interface 的基本使用就不再说明，很容易搜到，这里主要讨论下它们之间的区别：

主要区别是 type 一旦定义就不能添加新的属性（properties），而 interface 可以，可以参考官网的[例子](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces) （下面也给出了相关 code，但是由于没能解决 MDX 渲染 code block 的问题，所以没有官网展示得清晰）

```typescript
// Extending an interface
interface Animal {
  name: string
}

interface Bear extends Animal {
  honey: boolean
}

const bear = getBear()
bear.name
bear.honey

// Extending a type via intersections
type Animal = {
  name: string
}

type Bear = Animal & {
  honey: Boolean
}

const bear = getBear()
bear.name
bear.honey

// Adding new fields to an existing interface
interface Window {
  title: string
}

interface Window {
  ts: TypeScriptAPI
}

const src = 'const a = "Hello World"'
window.ts.transpileModule(src, {})

// A type cannot be changed after being created
type Window = {
  title: string
}

type Window = {
  ts: TypeScriptAPI
}

// Error: Duplicate identifier 'Window'.
```

另外还有以下几点：

- `type` 在 TS 4.2 之前或许会在错误提示中显示一些匿名类型（而非你指定的类型），这个结果或许不是你想要的，可以查看官网的[PlayGround](https://www.typescriptlang.org/play?ts=4.2.3#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA)，当你选择 TS 版本低于 4.2，并且鼠标 hover 在最下面的错误代码时，提示信息中并不会包含你指定的类名
- `type` 能够自定义命名原始数据类型（primitive），而 `interface` 不行
- 虽然 TS 是根据形状识别类型的（structural typing），但是如果不显示指定 `interface` 名而导致的报错，则不会显示该 `interface` 名，具体可以看下面的例子

```typescript
// Compiler error messages will always use
// the name of an interface:

interface Mammal {
  name: string
}

function echoMammal(m: Mammal) {
  console.log(m.name)
}

// e.g. The error below will always use the name Mammal
// to refer to the type which is expected:
echoMammal({ name: 12343 })

// The type of `m` here is the exact same as mammal,
// but as it's not been directly named, TypeScript
// won't mention it in the error messaging

function echoAnimal(m: { name: string }) {
  console.log(m.name)
}

echoAnimal({ name: 12345 })
```

大多数时候，你可以根据个人喜好选择使用 `type` 还是 `interface`，如果你喜欢启发式编程，则考虑使用 `interface`， 直到你需要 `type`的一些特性

</Primary>

<Warning title="参考连接">

1. [WangDoc JS 教程](https://wangdoc.com/javascript/types/number.html)
2. [对 js 中表达式和语句的理解](https://zhuanlan.zhihu.com/p/38622128#:~:text=%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%9C%A8js,%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%AF%94%E5%A6%82%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%EF%BC%9A&text=%E8%AF%AD%E5%8F%A5%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E4%BA%8E%EF%BC%8C%E8%AF%AD%E5%8F%A5%E6%98%AF%E4%B8%BA%E4%BA%86,%E7%9A%84%E5%80%BC%E4%B8%8D%E5%8C%85%E6%8B%ACundefined%EF%BC%89%E3%80%82)
3. [StackOverFlow 关于 double 表示](https://stackoverflow.com/questions/2003493/javascript-float-from-to-bits)

</Warning>
